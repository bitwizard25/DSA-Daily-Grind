# 🗓️ DAY 12 — Queues & Deques

> 💡 **Core Insight:** A monotonic deque lets you track the max/min of a sliding window in O(1) amortized by removing stale and dominated elements.

### 🟢 Problem 1: Implement Queue using Stacks
- **Approach:** Two stacks. `inbox` for push, `outbox` for pop. Transfer lazily.
- **Complexity:** Amortized O(1) per operation

```cpp
class MyQueue {
    stack<int> inbox, outbox;
    void transfer() {
        if (outbox.empty())
            while (!inbox.empty()) { outbox.push(inbox.top()); inbox.pop(); }
    }
public:
    void push(int x) { inbox.push(x); }
    int pop()  { transfer(); int v = outbox.top(); outbox.pop(); return v; }
    int peek() { transfer(); return outbox.top(); }
    bool empty() { return inbox.empty() && outbox.empty(); }
};
```

### 🔴 Problem 2: Sliding Window Maximum
- **Approach:** Deque stores indices. Remove stale (out of window) from front. Remove dominated (smaller) from back.
- **Complexity:** O(N) time | O(K) space

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq; // indices
    vector<int> res;
    for (int i = 0; i < (int)nums.size(); i++) {
        // Remove out-of-window from front
        if (!dq.empty() && dq.front() <= i - k) dq.pop_front();
        // Remove smaller elements from back
        while (!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
        dq.push_back(i);
        if (i >= k - 1) res.push_back(nums[dq.front()]);
    }
    return res;
}
```

### ✅ Day 12 Checklist
- [ ] Why is the two-stack queue amortized O(1), not O(N)?
- [ ] Trace Sliding Window Maximum on `[1,3,-1,-3,5,3,6,7]`, k=3
- [ ] What does "dominated" mean in the deque context?

---

